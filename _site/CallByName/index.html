<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Call-by-name big-step evaluation | Programming Language Foundations in Agda
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Call-by-name big-step evaluation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Programming Language Foundations in Agda" />
<meta property="og:description" content="Programming Language Foundations in Agda" />
<link rel="canonical" href="https://plfa.github.io/CallByName/" />
<meta property="og:url" content="https://plfa.github.io/CallByName/" />
<meta property="og:site_name" content="Programming Language Foundations in Agda" />
<script type="application/ld+json">
{"description":"Programming Language Foundations in Agda","@type":"WebPage","url":"https://plfa.github.io/CallByName/","headline":"Call-by-name big-step evaluation","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/">Programming Language Foundations in Agda
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/">Table of Contents</a>
                <a class="page-link" href="/GettingStarted/">Getting Started</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Call-by-name big-step evaluation</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/Confluence/">Prev</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/CallByName.lagda">Source</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/Denotational/">Next</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="164" class="Keyword">module</a> <a id="171" href="/CallByName/" class="Module">plfa.CallByName</a> <a id="187" class="Keyword">where</a></pre>

<h2 id="introduction">Introduction</h2>

<p>The call-by-name evaluation strategy is a deterministic method for
computing the value of a program in the lambda calculus.  That is,
call-by-name produces a value if and only if beta reduction can reduce
the program to a lambda abstraction. In this chapter we define
call-by-name evaluation and prove the forward direction of this
if-and-only-if. We postpone the backward direction until after we have
developed a denotational semantics for the lambda calculus, at which
point the proof will be an easy corollary of properties of the
denotational semantics.</p>

<p>We present the call-by-name strategy as a relation between an an input
term and an output value. Such a relation is often called a <em>big-step
semantics</em>, as it relates the input term directly to the final result,
in contrast to the small-step reduction relation <code class="highlighter-rouge">—→</code> that maps a term
to another term in which a single sub-computation has been completed.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="1161" class="Keyword">open</a> <a id="1166" class="Keyword">import</a> <a id="1173" href="/Untyped/" class="Module">plfa.Untyped</a>
  <a id="1188" class="Keyword">using</a> <a id="1194" class="Symbol">(</a><a id="1195" href="/Untyped/#2980" class="Datatype">Context</a><a id="1202" class="Symbol">;</a> <a id="1204" href="/Untyped/#4150" class="Datatype Operator">_⊢_</a><a id="1207" class="Symbol">;</a> <a id="1209" href="/Untyped/#3365" class="Datatype Operator">_∋_</a><a id="1212" class="Symbol">;</a> <a id="1214" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="1215" class="Symbol">;</a> <a id="1217" href="/Untyped/#3002" class="InductiveConstructor">∅</a><a id="1218" class="Symbol">;</a> <a id="1220" href="/Untyped/#3018" class="InductiveConstructor Operator">_,_</a><a id="1223" class="Symbol">;</a> <a id="1225" href="/Untyped/#3401" class="InductiveConstructor">Z</a><a id="1226" class="Symbol">;</a> <a id="1228" href="/Untyped/#3446" class="InductiveConstructor Operator">S_</a><a id="1230" class="Symbol">;</a> <a id="1232" href="/Untyped/#4186" class="InductiveConstructor Operator">`_</a><a id="1234" class="Symbol">;</a> <a id="1236" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ_</a><a id="1238" class="Symbol">;</a> <a id="1240" href="/Untyped/#4298" class="InductiveConstructor Operator">_·_</a><a id="1243" class="Symbol">;</a> <a id="1245" href="/Untyped/#6931" class="Function">subst</a><a id="1250" class="Symbol">;</a> <a id="1252" href="/Untyped/#7359" class="Function">subst-zero</a><a id="1262" class="Symbol">;</a>
         <a id="1273" href="/Untyped/#6623" class="Function">exts</a><a id="1277" class="Symbol">;</a> <a id="1279" href="/Untyped/#6171" class="Function">rename</a><a id="1285" class="Symbol">)</a>
<a id="1287" class="Keyword">open</a> <a id="1292" class="Keyword">import</a> <a id="1299" href="/LambdaReduction/" class="Module">plfa.LambdaReduction</a>
  <a id="1322" class="Keyword">using</a> <a id="1328" class="Symbol">(</a><a id="1329" href="/LambdaReduction/#616" class="InductiveConstructor">β</a><a id="1330" class="Symbol">;</a> <a id="1332" href="/LambdaReduction/#436" class="InductiveConstructor">ξ₁</a><a id="1334" class="Symbol">;</a> <a id="1336" href="/LambdaReduction/#526" class="InductiveConstructor">ξ₂</a><a id="1338" class="Symbol">;</a> <a id="1340" href="/LambdaReduction/#724" class="InductiveConstructor">ζ</a><a id="1341" class="Symbol">;</a> <a id="1343" href="/LambdaReduction/#386" class="Datatype Operator">_—→_</a><a id="1347" class="Symbol">;</a> <a id="1349" href="/LambdaReduction/#894" class="Datatype Operator">_—↠_</a><a id="1353" class="Symbol">;</a> <a id="1355" href="/LambdaReduction/#1001" class="InductiveConstructor Operator">_—→⟨_⟩_</a><a id="1362" class="Symbol">;</a> <a id="1364" href="/LambdaReduction/#944" class="InductiveConstructor Operator">_[]</a><a id="1367" class="Symbol">;</a> <a id="1369" href="/LambdaReduction/#1210" class="Function">—↠-trans</a><a id="1377" class="Symbol">;</a> <a id="1379" href="/LambdaReduction/#1923" class="Function">appL-cong</a><a id="1388" class="Symbol">)</a>
<a id="1390" class="Keyword">open</a> <a id="1395" class="Keyword">import</a> <a id="1402" href="/Substitution/" class="Module">plfa.Substitution</a>
  <a id="1422" class="Keyword">using</a> <a id="1428" class="Symbol">(</a><a id="1429" href="/Substitution/#2506" class="Function">Subst</a><a id="1434" class="Symbol">;</a> <a id="1436" href="/Substitution/#2663" class="Function Operator">⟪_⟫</a><a id="1439" class="Symbol">;</a> <a id="1441" href="/Substitution/#3592" class="Function Operator">_•_</a><a id="1444" class="Symbol">;</a> <a id="1446" href="/Substitution/#3945" class="Function Operator">_⨟_</a><a id="1449" class="Symbol">;</a> <a id="1451" href="/Substitution/#3179" class="Function">ids</a><a id="1454" class="Symbol">;</a> <a id="1456" href="/Substitution/#17610" class="Function">sub-id</a><a id="1462" class="Symbol">;</a> <a id="1464" href="/Substitution/#23724" class="Function">sub-sub</a><a id="1471" class="Symbol">;</a> <a id="1473" href="/Substitution/#25997" class="Function">subst-zero-exts-cons</a><a id="1493" class="Symbol">)</a>
<a id="1495" class="Keyword">import</a> <a id="1502" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1540" class="Symbol">as</a> <a id="1543" class="Module">Eq</a>
<a id="1546" class="Keyword">open</a> <a id="1551" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="1554" class="Keyword">using</a> <a id="1560" class="Symbol">(</a><a id="1561" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="1564" class="Symbol">;</a> <a id="1566" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="1570" class="Symbol">;</a> <a id="1572" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#887" class="Function">trans</a><a id="1577" class="Symbol">;</a> <a id="1579" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a><a id="1582" class="Symbol">)</a>
<a id="1584" class="Keyword">open</a> <a id="1589" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#3975" class="Module">Eq.≡-Reasoning</a> <a id="1604" class="Keyword">using</a> <a id="1610" class="Symbol">(</a><a id="1611" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin_</a><a id="1617" class="Symbol">;</a> <a id="1619" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">_≡⟨⟩_</a><a id="1624" class="Symbol">;</a> <a id="1626" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">_≡⟨_⟩_</a><a id="1632" class="Symbol">;</a> <a id="1634" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">_∎</a><a id="1636" class="Symbol">)</a>

<a id="1639" class="Keyword">open</a> <a id="1644" class="Keyword">import</a> <a id="1651" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html" class="Module">Data.Product</a> <a id="1664" class="Keyword">using</a> <a id="1670" class="Symbol">(</a><a id="1671" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#1353" class="Function Operator">_×_</a><a id="1674" class="Symbol">;</a> <a id="1676" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#69" class="Record">Σ</a><a id="1677" class="Symbol">;</a> <a id="1679" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">Σ-syntax</a><a id="1687" class="Symbol">;</a> <a id="1689" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#881" class="Function">∃</a><a id="1690" class="Symbol">;</a> <a id="1692" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#942" class="Function">∃-syntax</a><a id="1700" class="Symbol">;</a> <a id="1702" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#155" class="Field">proj₁</a><a id="1707" class="Symbol">;</a> <a id="1709" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#167" class="Field">proj₂</a><a id="1714" class="Symbol">)</a>
  <a id="1718" class="Keyword">renaming</a> <a id="1727" class="Symbol">(</a><a id="1728" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">_,_</a> <a id="1732" class="Symbol">to</a> <a id="1735" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="1740" class="Symbol">)</a>
<a id="1742" class="Keyword">open</a> <a id="1747" class="Keyword">import</a> <a id="1754" href="https://agda.github.io/agda-stdlib/v0.17/Function.html" class="Module">Function</a> <a id="1763" class="Keyword">using</a> <a id="1769" class="Symbol">(</a><a id="1770" href="https://agda.github.io/agda-stdlib/v0.17/Function.html#769" class="Function Operator">_∘_</a><a id="1773" class="Symbol">)</a></pre>

<h2 id="environments">Environments</h2>

<p>To handle variables and function application, there is the choice
between using substitution, as in <code class="highlighter-rouge">—→</code>, or to use an <em>environment</em>.
An environment in call-by-name is a map from variables to closures,
that is, to terms paired with their environments. We choose to use
environments instead of substitution because the point of the
call-by-name strategy is to be closer to an implementation of the
language. Also, the denotational semantics introduced in later
chapters uses environments and the proof of adequacy
is made easier by aligning these choices.</p>

<p>We define environments and closures as follows.</p>

<pre class="Agda"><a id="ClosEnv"></a><a id="2422" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="2430" class="Symbol">:</a> <a id="2432" href="/Untyped/#2980" class="Datatype">Context</a> <a id="2440" class="Symbol">→</a> <a id="2442" class="PrimitiveType">Set</a>

<a id="2447" class="Keyword">data</a> <a id="Clos"></a><a id="2452" href="/CallByName/#2452" class="Datatype">Clos</a> <a id="2457" class="Symbol">:</a> <a id="2459" class="PrimitiveType">Set</a> <a id="2463" class="Keyword">where</a>
  <a id="Clos.clos"></a><a id="2471" href="/CallByName/#2471" class="InductiveConstructor">clos</a> <a id="2476" class="Symbol">:</a> <a id="2478" class="Symbol">∀{</a><a id="2480" href="/CallByName/#2480" class="Bound">Γ</a><a id="2481" class="Symbol">}</a> <a id="2483" class="Symbol">→</a> <a id="2485" class="Symbol">(</a><a id="2486" href="/CallByName/#2486" class="Bound">M</a> <a id="2488" class="Symbol">:</a> <a id="2490" href="/CallByName/#2480" class="Bound">Γ</a> <a id="2492" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="2494" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="2495" class="Symbol">)</a> <a id="2497" class="Symbol">→</a> <a id="2499" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="2507" href="/CallByName/#2480" class="Bound">Γ</a> <a id="2509" class="Symbol">→</a> <a id="2511" href="/CallByName/#2452" class="Datatype">Clos</a>

<a id="2517" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="2525" href="/CallByName/#2525" class="Bound">Γ</a> <a id="2527" class="Symbol">=</a> <a id="2529" class="Symbol">∀</a> <a id="2531" class="Symbol">(</a><a id="2532" href="/CallByName/#2532" class="Bound">x</a> <a id="2534" class="Symbol">:</a> <a id="2536" href="/CallByName/#2525" class="Bound">Γ</a> <a id="2538" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="2540" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="2541" class="Symbol">)</a> <a id="2543" class="Symbol">→</a> <a id="2545" href="/CallByName/#2452" class="Datatype">Clos</a></pre>

<p>As usual, we have the empty environment, and we can extend an
environment.</p>

<pre class="Agda"><a id="∅&#39;"></a><a id="2651" href="/CallByName/#2651" class="Function">∅&#39;</a> <a id="2654" class="Symbol">:</a> <a id="2656" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="2664" href="/Untyped/#3002" class="InductiveConstructor">∅</a>
<a id="2666" href="/CallByName/#2651" class="Function">∅&#39;</a> <a id="2669" class="Symbol">()</a>

<a id="_,&#39;_"></a><a id="2673" href="/CallByName/#2673" class="Function Operator">_,&#39;_</a> <a id="2678" class="Symbol">:</a> <a id="2680" class="Symbol">∀</a> <a id="2682" class="Symbol">{</a><a id="2683" href="/CallByName/#2683" class="Bound">Γ</a><a id="2684" class="Symbol">}</a> <a id="2686" class="Symbol">→</a> <a id="2688" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="2696" href="/CallByName/#2683" class="Bound">Γ</a> <a id="2698" class="Symbol">→</a> <a id="2700" href="/CallByName/#2452" class="Datatype">Clos</a> <a id="2705" class="Symbol">→</a> <a id="2707" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="2715" class="Symbol">(</a><a id="2716" href="/CallByName/#2683" class="Bound">Γ</a> <a id="2718" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="2720" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="2721" class="Symbol">)</a>
<a id="2723" class="Symbol">(</a><a id="2724" href="/CallByName/#2724" class="Bound">γ</a> <a id="2726" href="/CallByName/#2673" class="Function Operator">,&#39;</a> <a id="2729" href="/CallByName/#2729" class="Bound">c</a><a id="2730" class="Symbol">)</a> <a id="2732" href="/Untyped/#3401" class="InductiveConstructor">Z</a> <a id="2734" class="Symbol">=</a> <a id="2736" href="/CallByName/#2729" class="Bound">c</a>
<a id="2738" class="Symbol">(</a><a id="2739" href="/CallByName/#2739" class="Bound">γ</a> <a id="2741" href="/CallByName/#2673" class="Function Operator">,&#39;</a> <a id="2744" href="/CallByName/#2744" class="Bound">c</a><a id="2745" class="Symbol">)</a> <a id="2747" class="Symbol">(</a><a id="2748" href="/Untyped/#3446" class="InductiveConstructor Operator">S</a> <a id="2750" href="/CallByName/#2750" class="Bound">x</a><a id="2751" class="Symbol">)</a> <a id="2753" class="Symbol">=</a> <a id="2755" href="/CallByName/#2739" class="Bound">γ</a> <a id="2757" href="/CallByName/#2750" class="Bound">x</a></pre>

<h2 id="big-step-evaluation">Big-step evaluation</h2>

<p>The big-step semantics is represented as a ternary relation,
written <code class="highlighter-rouge">γ ⊢ M ⇓ V</code>, where <code class="highlighter-rouge">γ</code> is the environment, <code class="highlighter-rouge">M</code> is the input
term, and <code class="highlighter-rouge">V</code> is the result value.  A <em>value</em> is a closure whose term
is a lambda abstraction.</p>

<pre class="Agda"><a id="3033" class="Keyword">data</a> <a id="_⊢_⇓_"></a><a id="3038" href="/CallByName/#3038" class="Datatype Operator">_⊢_⇓_</a> <a id="3044" class="Symbol">:</a> <a id="3046" class="Symbol">∀{</a><a id="3048" href="/CallByName/#3048" class="Bound">Γ</a><a id="3049" class="Symbol">}</a> <a id="3051" class="Symbol">→</a> <a id="3053" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="3061" href="/CallByName/#3048" class="Bound">Γ</a> <a id="3063" class="Symbol">→</a> <a id="3065" class="Symbol">(</a><a id="3066" href="/CallByName/#3048" class="Bound">Γ</a> <a id="3068" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="3070" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="3071" class="Symbol">)</a> <a id="3073" class="Symbol">→</a> <a id="3075" href="/CallByName/#2452" class="Datatype">Clos</a> <a id="3080" class="Symbol">→</a> <a id="3082" class="PrimitiveType">Set</a> <a id="3086" class="Keyword">where</a>

  <a id="_⊢_⇓_.⇓-var"></a><a id="3095" href="/CallByName/#3095" class="InductiveConstructor">⇓-var</a> <a id="3101" class="Symbol">:</a> <a id="3103" class="Symbol">∀{</a><a id="3105" href="/CallByName/#3105" class="Bound">Γ</a><a id="3106" class="Symbol">}{</a><a id="3108" href="/CallByName/#3108" class="Bound">γ</a> <a id="3110" class="Symbol">:</a> <a id="3112" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="3120" href="/CallByName/#3105" class="Bound">Γ</a><a id="3121" class="Symbol">}{</a><a id="3123" href="/CallByName/#3123" class="Bound">x</a> <a id="3125" class="Symbol">:</a> <a id="3127" href="/CallByName/#3105" class="Bound">Γ</a> <a id="3129" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="3131" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="3132" class="Symbol">}{</a><a id="3134" href="/CallByName/#3134" class="Bound">Δ</a><a id="3135" class="Symbol">}{</a><a id="3137" href="/CallByName/#3137" class="Bound">δ</a> <a id="3139" class="Symbol">:</a> <a id="3141" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="3149" href="/CallByName/#3134" class="Bound">Δ</a><a id="3150" class="Symbol">}{</a><a id="3152" href="/CallByName/#3152" class="Bound">M</a> <a id="3154" class="Symbol">:</a> <a id="3156" href="/CallByName/#3134" class="Bound">Δ</a> <a id="3158" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="3160" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="3161" class="Symbol">}{</a><a id="3163" href="/CallByName/#3163" class="Bound">V</a><a id="3164" class="Symbol">}</a>
        <a id="3174" class="Symbol">→</a> <a id="3176" href="/CallByName/#3108" class="Bound">γ</a> <a id="3178" href="/CallByName/#3123" class="Bound">x</a> <a id="3180" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="3182" href="/CallByName/#2471" class="InductiveConstructor">clos</a> <a id="3187" href="/CallByName/#3152" class="Bound">M</a> <a id="3189" href="/CallByName/#3137" class="Bound">δ</a>
        <a id="3199" class="Symbol">→</a> <a id="3201" href="/CallByName/#3137" class="Bound">δ</a> <a id="3203" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="3205" href="/CallByName/#3152" class="Bound">M</a> <a id="3207" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="3209" href="/CallByName/#3163" class="Bound">V</a>
          <a id="3221" class="Comment">-----------</a>
        <a id="3241" class="Symbol">→</a> <a id="3243" href="/CallByName/#3108" class="Bound">γ</a> <a id="3245" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="3247" href="/Untyped/#4186" class="InductiveConstructor Operator">`</a> <a id="3249" href="/CallByName/#3123" class="Bound">x</a> <a id="3251" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="3253" href="/CallByName/#3163" class="Bound">V</a>

  <a id="_⊢_⇓_.⇓-lam"></a><a id="3258" href="/CallByName/#3258" class="InductiveConstructor">⇓-lam</a> <a id="3264" class="Symbol">:</a> <a id="3266" class="Symbol">∀{</a><a id="3268" href="/CallByName/#3268" class="Bound">Γ</a><a id="3269" class="Symbol">}{</a><a id="3271" href="/CallByName/#3271" class="Bound">γ</a> <a id="3273" class="Symbol">:</a> <a id="3275" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="3283" href="/CallByName/#3268" class="Bound">Γ</a><a id="3284" class="Symbol">}{</a><a id="3286" href="/CallByName/#3286" class="Bound">M</a> <a id="3288" class="Symbol">:</a> <a id="3290" href="/CallByName/#3268" class="Bound">Γ</a> <a id="3292" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="3294" href="/Untyped/#2694" class="InductiveConstructor">★</a> <a id="3296" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="3298" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="3299" class="Symbol">}</a>
        <a id="3309" class="Symbol">→</a> <a id="3311" href="/CallByName/#3271" class="Bound">γ</a> <a id="3313" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="3315" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="3317" href="/CallByName/#3286" class="Bound">M</a> <a id="3319" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="3321" href="/CallByName/#2471" class="InductiveConstructor">clos</a> <a id="3326" class="Symbol">(</a><a id="3327" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="3329" href="/CallByName/#3286" class="Bound">M</a><a id="3330" class="Symbol">)</a> <a id="3332" href="/CallByName/#3271" class="Bound">γ</a>

  <a id="_⊢_⇓_.⇓-app"></a><a id="3337" href="/CallByName/#3337" class="InductiveConstructor">⇓-app</a> <a id="3343" class="Symbol">:</a> <a id="3345" class="Symbol">∀{</a><a id="3347" href="/CallByName/#3347" class="Bound">Γ</a><a id="3348" class="Symbol">}{</a><a id="3350" href="/CallByName/#3350" class="Bound">γ</a> <a id="3352" class="Symbol">:</a> <a id="3354" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="3362" href="/CallByName/#3347" class="Bound">Γ</a><a id="3363" class="Symbol">}{</a><a id="3365" href="/CallByName/#3365" class="Bound">L</a> <a id="3367" href="/CallByName/#3367" class="Bound">M</a> <a id="3369" class="Symbol">:</a> <a id="3371" href="/CallByName/#3347" class="Bound">Γ</a> <a id="3373" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="3375" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="3376" class="Symbol">}{</a><a id="3378" href="/CallByName/#3378" class="Bound">Δ</a><a id="3379" class="Symbol">}{</a><a id="3381" href="/CallByName/#3381" class="Bound">δ</a> <a id="3383" class="Symbol">:</a> <a id="3385" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="3393" href="/CallByName/#3378" class="Bound">Δ</a><a id="3394" class="Symbol">}{</a><a id="3396" href="/CallByName/#3396" class="Bound">N</a> <a id="3398" class="Symbol">:</a> <a id="3400" href="/CallByName/#3378" class="Bound">Δ</a> <a id="3402" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="3404" href="/Untyped/#2694" class="InductiveConstructor">★</a> <a id="3406" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="3408" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="3409" class="Symbol">}{</a><a id="3411" href="/CallByName/#3411" class="Bound">V</a><a id="3412" class="Symbol">}</a>
       <a id="3421" class="Symbol">→</a> <a id="3423" href="/CallByName/#3350" class="Bound">γ</a> <a id="3425" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="3427" href="/CallByName/#3365" class="Bound">L</a> <a id="3429" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="3431" href="/CallByName/#2471" class="InductiveConstructor">clos</a> <a id="3436" class="Symbol">(</a><a id="3437" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="3439" href="/CallByName/#3396" class="Bound">N</a><a id="3440" class="Symbol">)</a> <a id="3442" href="/CallByName/#3381" class="Bound">δ</a>   <a id="3446" class="Symbol">→</a>   <a id="3450" class="Symbol">(</a><a id="3451" href="/CallByName/#3381" class="Bound">δ</a> <a id="3453" href="/CallByName/#2673" class="Function Operator">,&#39;</a> <a id="3456" href="/CallByName/#2471" class="InductiveConstructor">clos</a> <a id="3461" href="/CallByName/#3367" class="Bound">M</a> <a id="3463" href="/CallByName/#3350" class="Bound">γ</a><a id="3464" class="Symbol">)</a> <a id="3466" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="3468" href="/CallByName/#3396" class="Bound">N</a> <a id="3470" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="3472" href="/CallByName/#3411" class="Bound">V</a>
         <a id="3483" class="Comment">---------------------------------------------------</a>
       <a id="3542" class="Symbol">→</a> <a id="3544" href="/CallByName/#3350" class="Bound">γ</a> <a id="3546" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="3548" href="/CallByName/#3365" class="Bound">L</a> <a id="3550" href="/Untyped/#4298" class="InductiveConstructor Operator">·</a> <a id="3552" href="/CallByName/#3367" class="Bound">M</a> <a id="3554" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="3556" href="/CallByName/#3411" class="Bound">V</a></pre>

<ul>
  <li>
    <p>The <code class="highlighter-rouge">⇓-var</code> rule evaluates a variable by finding the associated
closure in the environment and then evaluating the closure.</p>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">⇓-lam</code> rule turns a lambda abstraction into a closure
by packaging it up with its environment.</p>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">⇓-app</code> rule performs function application by first evaluating
the term <code class="highlighter-rouge">L</code> in operator position. If that produces a closure containing
a lambda abstraction <code class="highlighter-rouge">ƛ N</code>, then we evaluate the body <code class="highlighter-rouge">N</code> in an
environment extended with the argument <code class="highlighter-rouge">M</code>. Note that <code class="highlighter-rouge">M</code> is not
evaluated in rule <code class="highlighter-rouge">⇓-app</code> because this is call-by-name and not
call-by-value.</p>
  </li>
</ul>

<h2 id="the-big-step-semantics-is-deterministic">The big-step semantics is deterministic</h2>

<p>If the big-step relation evaluates a term <code class="highlighter-rouge">M</code> to both <code class="highlighter-rouge">V</code> and
<code class="highlighter-rouge">V′</code>, then <code class="highlighter-rouge">V</code> and <code class="highlighter-rouge">V′</code> must be identical. In other words, the
call-by-name relation is a partial function. The proof is a
straightforward induction on the two big-step derivations.</p>

<pre class="Agda"><a id="⇓-determ"></a><a id="4467" href="/CallByName/#4467" class="Function">⇓-determ</a> <a id="4476" class="Symbol">:</a> <a id="4478" class="Symbol">∀{</a><a id="4480" href="/CallByName/#4480" class="Bound">Γ</a><a id="4481" class="Symbol">}{</a><a id="4483" href="/CallByName/#4483" class="Bound">γ</a> <a id="4485" class="Symbol">:</a> <a id="4487" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="4495" href="/CallByName/#4480" class="Bound">Γ</a><a id="4496" class="Symbol">}{</a><a id="4498" href="/CallByName/#4498" class="Bound">M</a> <a id="4500" class="Symbol">:</a> <a id="4502" href="/CallByName/#4480" class="Bound">Γ</a> <a id="4504" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="4506" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="4507" class="Symbol">}{</a><a id="4509" href="/CallByName/#4509" class="Bound">V</a> <a id="4511" href="/CallByName/#4511" class="Bound">V&#39;</a> <a id="4514" class="Symbol">:</a> <a id="4516" href="/CallByName/#2452" class="Datatype">Clos</a><a id="4520" class="Symbol">}</a>
         <a id="4531" class="Symbol">→</a> <a id="4533" href="/CallByName/#4483" class="Bound">γ</a> <a id="4535" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="4537" href="/CallByName/#4498" class="Bound">M</a> <a id="4539" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="4541" href="/CallByName/#4509" class="Bound">V</a> <a id="4543" class="Symbol">→</a> <a id="4545" href="/CallByName/#4483" class="Bound">γ</a> <a id="4547" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="4549" href="/CallByName/#4498" class="Bound">M</a> <a id="4551" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="4553" href="/CallByName/#4511" class="Bound">V&#39;</a>
         <a id="4565" class="Symbol">→</a> <a id="4567" href="/CallByName/#4509" class="Bound">V</a> <a id="4569" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="4571" href="/CallByName/#4511" class="Bound">V&#39;</a>
<a id="4574" href="/CallByName/#4467" class="Function">⇓-determ</a> <a id="4583" class="Symbol">(</a><a id="4584" href="/CallByName/#3095" class="InductiveConstructor">⇓-var</a> <a id="4590" href="/CallByName/#4590" class="Bound">eq1</a> <a id="4594" href="/CallByName/#4594" class="Bound">mc</a><a id="4596" class="Symbol">)</a> <a id="4598" class="Symbol">(</a><a id="4599" href="/CallByName/#3095" class="InductiveConstructor">⇓-var</a> <a id="4605" href="/CallByName/#4605" class="Bound">eq2</a> <a id="4609" href="/CallByName/#4609" class="Bound">mc&#39;</a><a id="4612" class="Symbol">)</a>
      <a id="4620" class="Keyword">with</a> <a id="4625" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#887" class="Function">trans</a> <a id="4631" class="Symbol">(</a><a id="4632" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a> <a id="4636" href="/CallByName/#4590" class="Bound">eq1</a><a id="4639" class="Symbol">)</a> <a id="4641" href="/CallByName/#4605" class="Bound">eq2</a>
<a id="4645" class="Symbol">...</a> <a id="4649" class="Symbol">|</a> <a id="4651" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="4656" class="Symbol">=</a> <a id="4658" href="/CallByName/#4467" class="Function">⇓-determ</a> <a id="4667" class="Bound">mc</a> <a id="4670" class="Bound">mc&#39;</a>
<a id="4674" href="/CallByName/#4467" class="Function">⇓-determ</a> <a id="4683" href="/CallByName/#3258" class="InductiveConstructor">⇓-lam</a> <a id="4689" href="/CallByName/#3258" class="InductiveConstructor">⇓-lam</a> <a id="4695" class="Symbol">=</a> <a id="4697" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="4702" href="/CallByName/#4467" class="Function">⇓-determ</a> <a id="4711" class="Symbol">(</a><a id="4712" href="/CallByName/#3337" class="InductiveConstructor">⇓-app</a> <a id="4718" href="/CallByName/#4718" class="Bound">mc</a> <a id="4721" href="/CallByName/#4721" class="Bound">mc₁</a><a id="4724" class="Symbol">)</a> <a id="4726" class="Symbol">(</a><a id="4727" href="/CallByName/#3337" class="InductiveConstructor">⇓-app</a> <a id="4733" href="/CallByName/#4733" class="Bound">mc&#39;</a> <a id="4737" href="/CallByName/#4737" class="Bound">mc&#39;&#39;</a><a id="4741" class="Symbol">)</a> 
    <a id="4748" class="Keyword">with</a> <a id="4753" href="/CallByName/#4467" class="Function">⇓-determ</a> <a id="4762" href="/CallByName/#4718" class="Bound">mc</a> <a id="4765" href="/CallByName/#4733" class="Bound">mc&#39;</a>
<a id="4769" class="Symbol">...</a> <a id="4773" class="Symbol">|</a> <a id="4775" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="4780" class="Symbol">=</a> <a id="4782" href="/CallByName/#4467" class="Function">⇓-determ</a> <a id="4791" class="Bound">mc₁</a> <a id="4795" class="Bound">mc&#39;&#39;</a></pre>

<h2 id="big-step-evaluation-implies-beta-reduction-to-a-lambda">Big-step evaluation implies beta reduction to a lambda</h2>

<p>If big-step evaluation produces a value, then the input term can
reduce to a lambda abstraction by beta reduction:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ∅' ⊢ M ⇓ clos (ƛ N′) δ
  -----------------------------
→ Σ[ N ∈ ∅ , ★ ⊢ ★ ] (M —↠ ƛ N)
</code></pre></div></div>

<p>The proof is by induction on the big-step derivation. As is often
necessary, one must generalize the statement to get the induction to
go through. In the case for <code class="highlighter-rouge">⇓-app</code> (function application), the
argument is added to the environment, so the environment becomes
non-empty. The corresponding β reduction substitutes the argument into
the body of the lambda abstraction.  So we generalize the lemma to
allow an arbitrary environment <code class="highlighter-rouge">γ</code> and we add a premise that relates
the environment <code class="highlighter-rouge">γ</code> to an equivalent substitution <code class="highlighter-rouge">σ</code>.</p>

<p>The case for <code class="highlighter-rouge">⇓-app</code> also requires that we strengthen the
conclusion. In the case for <code class="highlighter-rouge">⇓-app</code> we have <code class="highlighter-rouge">γ ⊢ L ⇓ clos (λ N) δ</code> and
the induction hypothesis gives us <code class="highlighter-rouge">L —↠ ƛ N′</code>, but we need to know
that <code class="highlighter-rouge">N</code> and <code class="highlighter-rouge">N′</code> are equivalent. In particular, that <code class="highlighter-rouge">N ≡ subst τ N′</code>
where <code class="highlighter-rouge">τ</code> is the substitution that is equivalent to <code class="highlighter-rouge">δ</code>. Therefore we
expand the conclusion of the statement, stating that the results are
equivalent.</p>

<p>We make the two notions of equivalence precise by defining the
following two mutually-recursive predicates <code class="highlighter-rouge">c ≈ M</code> and <code class="highlighter-rouge">γ ≈ₑ σ</code>.</p>

<pre class="Agda"><a id="_≈_"></a><a id="6179" href="/CallByName/#6179" class="Function Operator">_≈_</a> <a id="6183" class="Symbol">:</a> <a id="6185" href="/CallByName/#2452" class="Datatype">Clos</a> <a id="6190" class="Symbol">→</a> <a id="6192" class="Symbol">(</a><a id="6193" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="6195" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="6197" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="6198" class="Symbol">)</a> <a id="6200" class="Symbol">→</a> <a id="6202" class="PrimitiveType">Set</a>
<a id="_≈ₑ_"></a><a id="6206" href="/CallByName/#6206" class="Function Operator">_≈ₑ_</a> <a id="6211" class="Symbol">:</a> <a id="6213" class="Symbol">∀{</a><a id="6215" href="/CallByName/#6215" class="Bound">Γ</a><a id="6216" class="Symbol">}</a> <a id="6218" class="Symbol">→</a> <a id="6220" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="6228" href="/CallByName/#6215" class="Bound">Γ</a> <a id="6230" class="Symbol">→</a> <a id="6232" href="/Substitution/#2506" class="Function">Subst</a> <a id="6238" href="/CallByName/#6215" class="Bound">Γ</a> <a id="6240" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="6242" class="Symbol">→</a> <a id="6244" class="PrimitiveType">Set</a>

<a id="6249" class="Symbol">(</a><a id="6250" href="/CallByName/#2471" class="InductiveConstructor">clos</a> <a id="6255" class="Symbol">{</a><a id="6256" href="/CallByName/#6256" class="Bound">Γ</a><a id="6257" class="Symbol">}</a> <a id="6259" href="/CallByName/#6259" class="Bound">M</a> <a id="6261" href="/CallByName/#6261" class="Bound">γ</a><a id="6262" class="Symbol">)</a> <a id="6264" href="/CallByName/#6179" class="Function Operator">≈</a> <a id="6266" href="/CallByName/#6266" class="Bound">N</a> <a id="6268" class="Symbol">=</a> <a id="6270" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">Σ[</a> <a id="6273" href="/CallByName/#6273" class="Bound">σ</a> <a id="6275" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">∈</a> <a id="6277" href="/Substitution/#2506" class="Function">Subst</a> <a id="6283" href="/CallByName/#6256" class="Bound">Γ</a> <a id="6285" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="6287" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">]</a> <a id="6289" href="/CallByName/#6261" class="Bound">γ</a> <a id="6291" href="/CallByName/#6206" class="Function Operator">≈ₑ</a> <a id="6294" href="/CallByName/#6273" class="Bound">σ</a> <a id="6296" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#1353" class="Function Operator">×</a> <a id="6298" class="Symbol">(</a><a id="6299" href="/CallByName/#6266" class="Bound">N</a> <a id="6301" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="6303" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="6305" href="/CallByName/#6273" class="Bound">σ</a> <a id="6307" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="6309" href="/CallByName/#6259" class="Bound">M</a><a id="6310" class="Symbol">)</a>

<a id="6313" href="/CallByName/#6313" class="Bound">γ</a> <a id="6315" href="/CallByName/#6206" class="Function Operator">≈ₑ</a> <a id="6318" href="/CallByName/#6318" class="Bound">σ</a> <a id="6320" class="Symbol">=</a> <a id="6322" class="Symbol">∀{</a><a id="6324" href="/CallByName/#6324" class="Bound">x</a><a id="6325" class="Symbol">}</a> <a id="6327" class="Symbol">→</a> <a id="6329" class="Symbol">(</a><a id="6330" href="/CallByName/#6313" class="Bound">γ</a> <a id="6332" href="/CallByName/#6324" class="Bound">x</a><a id="6333" class="Symbol">)</a> <a id="6335" href="/CallByName/#6179" class="Function Operator">≈</a> <a id="6337" class="Symbol">(</a><a id="6338" href="/CallByName/#6318" class="Bound">σ</a> <a id="6340" href="/CallByName/#6324" class="Bound">x</a><a id="6341" class="Symbol">)</a></pre>

<p>We can now state the main lemma:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If γ ⊢ M ⇓ c  and  γ ≈ₑ σ,
then  ⟪ σ ⟫ M —↠ N  and  c ≈ N  for some N.
</code></pre></div></div>

<p>Before starting the proof, we establish a couple lemmas
about equivalent environments and substitutions.</p>

<p>The empty environment is equivalent to the identity substitution.</p>

<pre class="Agda"><a id="≈ₑ-id"></a><a id="6655" href="/CallByName/#6655" class="Function">≈ₑ-id</a> <a id="6661" class="Symbol">:</a> <a id="6663" href="/CallByName/#2651" class="Function">∅&#39;</a> <a id="6666" href="/CallByName/#6206" class="Function Operator">≈ₑ</a> <a id="6669" href="/Substitution/#3179" class="Function">ids</a>
<a id="6673" href="/CallByName/#6655" class="Function">≈ₑ-id</a> <a id="6679" class="Symbol">{()}</a></pre>

<p>We define an auxilliary function for extending a substitution.</p>

<pre class="Agda"><a id="ext-subst"></a><a id="6773" href="/CallByName/#6773" class="Function">ext-subst</a> <a id="6783" class="Symbol">:</a> <a id="6785" class="Symbol">∀{</a><a id="6787" href="/CallByName/#6787" class="Bound">Γ</a> <a id="6789" href="/CallByName/#6789" class="Bound">Δ</a><a id="6790" class="Symbol">}</a> <a id="6792" class="Symbol">→</a> <a id="6794" href="/Substitution/#2506" class="Function">Subst</a> <a id="6800" href="/CallByName/#6787" class="Bound">Γ</a> <a id="6802" href="/CallByName/#6789" class="Bound">Δ</a> <a id="6804" class="Symbol">→</a> <a id="6806" href="/CallByName/#6789" class="Bound">Δ</a> <a id="6808" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="6810" href="/Untyped/#2694" class="InductiveConstructor">★</a> <a id="6812" class="Symbol">→</a> <a id="6814" href="/Substitution/#2506" class="Function">Subst</a> <a id="6820" class="Symbol">(</a><a id="6821" href="/CallByName/#6787" class="Bound">Γ</a> <a id="6823" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="6825" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="6826" class="Symbol">)</a> <a id="6828" href="/CallByName/#6789" class="Bound">Δ</a>
<a id="6830" href="/CallByName/#6773" class="Function">ext-subst</a><a id="6839" class="Symbol">{</a><a id="6840" href="/CallByName/#6840" class="Bound">Γ</a><a id="6841" class="Symbol">}{</a><a id="6843" href="/CallByName/#6843" class="Bound">Δ</a><a id="6844" class="Symbol">}</a> <a id="6846" href="/CallByName/#6846" class="Bound">σ</a> <a id="6848" href="/CallByName/#6848" class="Bound">N</a> <a id="6850" class="Symbol">{</a><a id="6851" href="/CallByName/#6851" class="Bound">A</a><a id="6852" class="Symbol">}</a> <a id="6854" class="Symbol">=</a> <a id="6856" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="6858" href="/Untyped/#7359" class="Function">subst-zero</a> <a id="6869" href="/CallByName/#6848" class="Bound">N</a> <a id="6871" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="6873" href="https://agda.github.io/agda-stdlib/v0.17/Function.html#769" class="Function Operator">∘</a> <a id="6875" href="/Untyped/#6623" class="Function">exts</a> <a id="6880" href="/CallByName/#6846" class="Bound">σ</a></pre>

<p>The next lemma states that if you start with an equivalent
environment and substitution <code class="highlighter-rouge">γ ≈ₑ σ</code>, extending them with
an equivalent closure and term <code class="highlighter-rouge">c ≈ N</code> produces
an equivalent environment and substitution:
<code class="highlighter-rouge">(γ ,' c) ≈ₑ (ext-subst σ N)</code>.</p>

<pre class="Agda"><a id="≈ₑ-ext"></a><a id="7150" href="/CallByName/#7150" class="Function">≈ₑ-ext</a> <a id="7157" class="Symbol">:</a> <a id="7159" class="Symbol">∀</a> <a id="7161" class="Symbol">{</a><a id="7162" href="/CallByName/#7162" class="Bound">Γ</a><a id="7163" class="Symbol">}</a> <a id="7165" class="Symbol">{</a><a id="7166" href="/CallByName/#7166" class="Bound">γ</a> <a id="7168" class="Symbol">:</a> <a id="7170" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="7178" href="/CallByName/#7162" class="Bound">Γ</a><a id="7179" class="Symbol">}</a> <a id="7181" class="Symbol">{</a><a id="7182" href="/CallByName/#7182" class="Bound">σ</a> <a id="7184" class="Symbol">:</a> <a id="7186" href="/Substitution/#2506" class="Function">Subst</a> <a id="7192" href="/CallByName/#7162" class="Bound">Γ</a> <a id="7194" href="/Untyped/#3002" class="InductiveConstructor">∅</a><a id="7195" class="Symbol">}</a> <a id="7197" class="Symbol">{</a><a id="7198" href="/CallByName/#7198" class="Bound">c</a><a id="7199" class="Symbol">}</a> <a id="7201" class="Symbol">{</a><a id="7202" href="/CallByName/#7202" class="Bound">N</a> <a id="7204" class="Symbol">:</a> <a id="7206" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="7208" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="7210" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="7211" class="Symbol">}</a>
      <a id="7219" class="Symbol">→</a> <a id="7221" href="/CallByName/#7166" class="Bound">γ</a> <a id="7223" href="/CallByName/#6206" class="Function Operator">≈ₑ</a> <a id="7226" href="/CallByName/#7182" class="Bound">σ</a>  <a id="7229" class="Symbol">→</a>  <a id="7232" href="/CallByName/#7198" class="Bound">c</a> <a id="7234" href="/CallByName/#6179" class="Function Operator">≈</a> <a id="7236" href="/CallByName/#7202" class="Bound">N</a>
        <a id="7246" class="Comment">--------------------------</a>
      <a id="7279" class="Symbol">→</a> <a id="7281" class="Symbol">(</a><a id="7282" href="/CallByName/#7166" class="Bound">γ</a> <a id="7284" href="/CallByName/#2673" class="Function Operator">,&#39;</a> <a id="7287" href="/CallByName/#7198" class="Bound">c</a><a id="7288" class="Symbol">)</a> <a id="7290" href="/CallByName/#6206" class="Function Operator">≈ₑ</a> <a id="7293" class="Symbol">(</a><a id="7294" href="/CallByName/#6773" class="Function">ext-subst</a> <a id="7304" href="/CallByName/#7182" class="Bound">σ</a> <a id="7306" href="/CallByName/#7202" class="Bound">N</a><a id="7307" class="Symbol">)</a>
<a id="7309" href="/CallByName/#7150" class="Function">≈ₑ-ext</a> <a id="7316" class="Symbol">{</a><a id="7317" href="/CallByName/#7317" class="Bound">Γ</a><a id="7318" class="Symbol">}</a> <a id="7320" class="Symbol">{</a><a id="7321" href="/CallByName/#7321" class="Bound">γ</a><a id="7322" class="Symbol">}</a> <a id="7324" class="Symbol">{</a><a id="7325" href="/CallByName/#7325" class="Bound">σ</a><a id="7326" class="Symbol">}</a> <a id="7328" class="Symbol">{</a><a id="7329" href="/CallByName/#7329" class="Bound">c</a><a id="7330" class="Symbol">}</a> <a id="7332" class="Symbol">{</a><a id="7333" href="/CallByName/#7333" class="Bound">N</a><a id="7334" class="Symbol">}</a> <a id="7336" href="/CallByName/#7336" class="Bound">γ≈ₑσ</a> <a id="7341" href="/CallByName/#7341" class="Bound">c≈N</a> <a id="7345" class="Symbol">{</a><a id="7346" href="/CallByName/#7346" class="Bound">x</a><a id="7347" class="Symbol">}</a> <a id="7349" class="Symbol">=</a> <a id="7351" href="/CallByName/#7450" class="Function">goal</a>
   <a id="7359" class="Keyword">where</a>
   <a id="7368" href="/CallByName/#7368" class="Function">ext-cons</a> <a id="7377" class="Symbol">:</a> <a id="7379" class="Symbol">(</a><a id="7380" href="/CallByName/#7321" class="Bound">γ</a> <a id="7382" href="/CallByName/#2673" class="Function Operator">,&#39;</a> <a id="7385" href="/CallByName/#7329" class="Bound">c</a><a id="7386" class="Symbol">)</a> <a id="7388" href="/CallByName/#6206" class="Function Operator">≈ₑ</a> <a id="7391" class="Symbol">(</a><a id="7392" href="/CallByName/#7333" class="Bound">N</a> <a id="7394" href="/Substitution/#3592" class="Function Operator">•</a> <a id="7396" href="/CallByName/#7325" class="Bound">σ</a><a id="7397" class="Symbol">)</a>
   <a id="7402" href="/CallByName/#7368" class="Function">ext-cons</a> <a id="7411" class="Symbol">{</a><a id="7412" href="/Untyped/#3401" class="InductiveConstructor">Z</a><a id="7413" class="Symbol">}</a> <a id="7415" class="Symbol">=</a> <a id="7417" href="/CallByName/#7341" class="Bound">c≈N</a>
   <a id="7424" href="/CallByName/#7368" class="Function">ext-cons</a> <a id="7433" class="Symbol">{</a><a id="7434" href="/Untyped/#3446" class="InductiveConstructor Operator">S</a> <a id="7436" href="/CallByName/#7436" class="Bound">x</a><a id="7437" class="Symbol">}</a> <a id="7439" class="Symbol">=</a> <a id="7441" href="/CallByName/#7336" class="Bound">γ≈ₑσ</a>

   <a id="7450" href="/CallByName/#7450" class="Function">goal</a> <a id="7455" class="Symbol">:</a> <a id="7457" class="Symbol">(</a><a id="7458" href="/CallByName/#7321" class="Bound">γ</a> <a id="7460" href="/CallByName/#2673" class="Function Operator">,&#39;</a> <a id="7463" href="/CallByName/#7329" class="Bound">c</a><a id="7464" class="Symbol">)</a> <a id="7466" href="/CallByName/#7346" class="Bound">x</a> <a id="7468" href="/CallByName/#6179" class="Function Operator">≈</a> <a id="7470" href="/CallByName/#6773" class="Function">ext-subst</a> <a id="7480" href="/CallByName/#7325" class="Bound">σ</a> <a id="7482" href="/CallByName/#7333" class="Bound">N</a> <a id="7484" href="/CallByName/#7346" class="Bound">x</a>
   <a id="7489" href="/CallByName/#7450" class="Function">goal</a>
       <a id="7501" class="Keyword">with</a> <a id="7506" href="/CallByName/#7368" class="Function">ext-cons</a> <a id="7515" class="Symbol">{</a><a id="7516" href="/CallByName/#7346" class="Bound">x</a><a id="7517" class="Symbol">}</a>
   <a id="7522" class="Symbol">...</a> <a id="7526" class="Symbol">|</a> <a id="7528" href="/CallByName/#7528" class="Bound">a</a> <a id="7530" class="Keyword">rewrite</a> <a id="7538" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a> <a id="7542" class="Symbol">(</a><a id="7543" href="/Substitution/#25997" class="Function">subst-zero-exts-cons</a><a id="7563" class="Symbol">{</a><a id="7564" href="/CallByName/#7317" class="Bound">Γ</a><a id="7565" class="Symbol">}{</a><a id="7567" href="/Untyped/#3002" class="InductiveConstructor">∅</a><a id="7568" class="Symbol">}{</a><a id="7570" href="/CallByName/#7325" class="Bound">σ</a><a id="7571" class="Symbol">}{</a><a id="7573" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="7574" class="Symbol">}{</a><a id="7576" href="/CallByName/#7333" class="Bound">N</a><a id="7577" class="Symbol">}{</a><a id="7579" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="7580" class="Symbol">})</a> <a id="7583" class="Symbol">=</a> <a id="7585" href="/CallByName/#7528" class="Bound">a</a></pre>

<p>To prove <code class="highlighter-rouge">≈ₑ-ext</code>, we make use of the fact that <code class="highlighter-rouge">ext-subst σ N</code> is
equivalent to <code class="highlighter-rouge">N • σ</code> (by <code class="highlighter-rouge">subst-zero-exts-cons</code>). So we just
need to prove that <code class="highlighter-rouge">(γ ,' c) ≈ₑ (N • σ)</code>, which is easy.
We proceed by cases on the input variable.</p>

<ul>
  <li>
    <p>If it is <code class="highlighter-rouge">Z</code>, then we immediately conclude using the
premise <code class="highlighter-rouge">c ≈ N</code>.</p>
  </li>
  <li>
    <p>If it is <code class="highlighter-rouge">S x</code>, then we immediately conclude using
premise <code class="highlighter-rouge">γ ≈ₑ σ</code>.</p>
  </li>
</ul>

<p>We arive at the main lemma: if <code class="highlighter-rouge">M</code> big steps to a
closure <code class="highlighter-rouge">c</code> in environment <code class="highlighter-rouge">γ</code>, and if <code class="highlighter-rouge">γ ≈ₑ σ</code>, then <code class="highlighter-rouge">⟪ σ ⟫ M</code> reduces
to some term <code class="highlighter-rouge">N</code> that is equivalent to <code class="highlighter-rouge">c</code>. We describe the proof
below.</p>

<pre class="Agda"><a id="⇓→—↠×𝔹"></a><a id="8188" href="/CallByName/#8188" class="Function">⇓→—↠×𝔹</a> <a id="8195" class="Symbol">:</a> <a id="8197" class="Symbol">∀{</a><a id="8199" href="/CallByName/#8199" class="Bound">Γ</a><a id="8200" class="Symbol">}{</a><a id="8202" href="/CallByName/#8202" class="Bound">γ</a> <a id="8204" class="Symbol">:</a> <a id="8206" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="8214" href="/CallByName/#8199" class="Bound">Γ</a><a id="8215" class="Symbol">}{</a><a id="8217" href="/CallByName/#8217" class="Bound">σ</a> <a id="8219" class="Symbol">:</a> <a id="8221" href="/Substitution/#2506" class="Function">Subst</a> <a id="8227" href="/CallByName/#8199" class="Bound">Γ</a> <a id="8229" href="/Untyped/#3002" class="InductiveConstructor">∅</a><a id="8230" class="Symbol">}{</a><a id="8232" href="/CallByName/#8232" class="Bound">M</a> <a id="8234" class="Symbol">:</a> <a id="8236" href="/CallByName/#8199" class="Bound">Γ</a> <a id="8238" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="8240" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="8241" class="Symbol">}{</a><a id="8243" href="/CallByName/#8243" class="Bound">c</a> <a id="8245" class="Symbol">:</a> <a id="8247" href="/CallByName/#2452" class="Datatype">Clos</a><a id="8251" class="Symbol">}</a>
       <a id="8260" class="Symbol">→</a> <a id="8262" href="/CallByName/#8202" class="Bound">γ</a> <a id="8264" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="8266" href="/CallByName/#8232" class="Bound">M</a> <a id="8268" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="8270" href="/CallByName/#8243" class="Bound">c</a>  <a id="8273" class="Symbol">→</a>  <a id="8276" href="/CallByName/#8202" class="Bound">γ</a> <a id="8278" href="/CallByName/#6206" class="Function Operator">≈ₑ</a> <a id="8281" href="/CallByName/#8217" class="Bound">σ</a>
         <a id="8292" class="Comment">---------------------------------------</a>
       <a id="8339" class="Symbol">→</a> <a id="8341" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">Σ[</a> <a id="8344" href="/CallByName/#8344" class="Bound">N</a> <a id="8346" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">∈</a> <a id="8348" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="8350" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="8352" href="/Untyped/#2694" class="InductiveConstructor">★</a> <a id="8354" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">]</a> <a id="8356" class="Symbol">(</a><a id="8357" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="8359" href="/CallByName/#8217" class="Bound">σ</a> <a id="8361" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="8363" href="/CallByName/#8232" class="Bound">M</a> <a id="8365" href="/LambdaReduction/#894" class="Datatype Operator">—↠</a> <a id="8368" href="/CallByName/#8344" class="Bound">N</a><a id="8369" class="Symbol">)</a> <a id="8371" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#1353" class="Function Operator">×</a> <a id="8373" href="/CallByName/#8243" class="Bound">c</a> <a id="8375" href="/CallByName/#6179" class="Function Operator">≈</a> <a id="8377" href="/CallByName/#8344" class="Bound">N</a>
<a id="8379" href="/CallByName/#8188" class="Function">⇓→—↠×𝔹</a> <a id="8386" class="Symbol">{</a><a id="8387" class="Argument">γ</a> <a id="8389" class="Symbol">=</a> <a id="8391" href="/CallByName/#8391" class="Bound">γ</a><a id="8392" class="Symbol">}</a> <a id="8394" class="Symbol">(</a><a id="8395" href="/CallByName/#3095" class="InductiveConstructor">⇓-var</a><a id="8400" class="Symbol">{</a><a id="8401" class="Argument">x</a> <a id="8403" class="Symbol">=</a> <a id="8405" href="/CallByName/#8405" class="Bound">x</a><a id="8406" class="Symbol">}</a> <a id="8408" href="/CallByName/#8408" class="Bound">γx≡Lδ</a> <a id="8414" href="/CallByName/#8414" class="Bound">δ⊢L⇓c</a><a id="8419" class="Symbol">)</a> <a id="8421" href="/CallByName/#8421" class="Bound">γ≈ₑσ</a>
    <a id="8430" class="Keyword">with</a> <a id="8435" href="/CallByName/#8391" class="Bound">γ</a> <a id="8437" href="/CallByName/#8405" class="Bound">x</a> <a id="8439" class="Symbol">|</a> <a id="8441" href="/CallByName/#8421" class="Bound">γ≈ₑσ</a> <a id="8446" class="Symbol">{</a><a id="8447" href="/CallByName/#8405" class="Bound">x</a><a id="8448" class="Symbol">}</a> <a id="8450" class="Symbol">|</a> <a id="8452" href="/CallByName/#8408" class="Bound">γx≡Lδ</a>
<a id="8458" class="Symbol">...</a> <a id="8462" class="Symbol">|</a> <a id="8464" href="/CallByName/#2471" class="InductiveConstructor">clos</a> <a id="8469" href="/CallByName/#8469" class="Bound">L</a> <a id="8471" href="/CallByName/#8471" class="Bound">δ</a> <a id="8473" class="Symbol">|</a> <a id="8475" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8477" href="/CallByName/#8477" class="Bound">τ</a> <a id="8479" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8481" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8483" href="/CallByName/#8483" class="Bound">δ≈ₑτ</a> <a id="8488" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8490" href="/CallByName/#8490" class="Bound">σx≡τL</a> <a id="8496" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8498" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8500" class="Symbol">|</a> <a id="8502" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
    <a id="8511" class="Keyword">with</a> <a id="8516" href="/CallByName/#8188" class="Function">⇓→—↠×𝔹</a><a id="8522" class="Symbol">{</a><a id="8523" class="Argument">σ</a> <a id="8525" class="Symbol">=</a> <a id="8527" href="/CallByName/#8477" class="Bound">τ</a><a id="8528" class="Symbol">}</a> <a id="8530" class="Bound">δ⊢L⇓c</a> <a id="8536" href="/CallByName/#8483" class="Bound">δ≈ₑτ</a>
<a id="8541" class="Symbol">...</a> <a id="8545" class="Symbol">|</a> <a id="8547" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8549" href="/CallByName/#8549" class="Bound">N</a> <a id="8551" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8553" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8555" href="/CallByName/#8555" class="Bound">τL—↠N</a> <a id="8561" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8563" href="/CallByName/#8563" class="Bound">c≈N</a> <a id="8567" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8569" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8571" class="Keyword">rewrite</a> <a id="8579" class="Bound">σx≡τL</a> <a id="8585" class="Symbol">=</a>
      <a id="8593" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8595" href="/CallByName/#8549" class="Bound">N</a> <a id="8597" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8599" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8601" href="/CallByName/#8555" class="Bound">τL—↠N</a> <a id="8607" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8609" href="/CallByName/#8563" class="Bound">c≈N</a> <a id="8613" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8615" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="8617" href="/CallByName/#8188" class="Function">⇓→—↠×𝔹</a> <a id="8624" class="Symbol">{</a><a id="8625" class="Argument">σ</a> <a id="8627" class="Symbol">=</a> <a id="8629" href="/CallByName/#8629" class="Bound">σ</a><a id="8630" class="Symbol">}</a> <a id="8632" class="Symbol">{</a><a id="8633" class="Argument">c</a> <a id="8635" class="Symbol">=</a> <a id="8637" href="/CallByName/#2471" class="InductiveConstructor">clos</a> <a id="8642" class="Symbol">(</a><a id="8643" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="8645" href="/CallByName/#8645" class="Bound">N</a><a id="8646" class="Symbol">)</a> <a id="8648" href="/CallByName/#8648" class="Bound">γ</a><a id="8649" class="Symbol">}</a> <a id="8651" href="/CallByName/#3258" class="InductiveConstructor">⇓-lam</a> <a id="8657" href="/CallByName/#8657" class="Bound">γ≈ₑσ</a> <a id="8662" class="Symbol">=</a>
    <a id="8668" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8670" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="8672" href="/CallByName/#8629" class="Bound">σ</a> <a id="8674" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="8676" class="Symbol">(</a><a id="8677" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="8679" href="/CallByName/#8645" class="Bound">N</a><a id="8680" class="Symbol">)</a> <a id="8682" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8684" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8686" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="8688" href="/CallByName/#8629" class="Bound">σ</a> <a id="8690" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="8692" class="Symbol">(</a><a id="8693" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="8695" href="/CallByName/#8645" class="Bound">N</a><a id="8696" class="Symbol">)</a> <a id="8698" href="/LambdaReduction/#944" class="InductiveConstructor Operator">[]</a> <a id="8701" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8703" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8705" href="/CallByName/#8629" class="Bound">σ</a> <a id="8707" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8709" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8711" href="/CallByName/#8657" class="Bound">γ≈ₑσ</a> <a id="8716" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8718" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="8723" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8725" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8727" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8729" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="8731" href="/CallByName/#8188" class="Function">⇓→—↠×𝔹</a><a id="8737" class="Symbol">{</a><a id="8738" href="/CallByName/#8738" class="Bound">Γ</a><a id="8739" class="Symbol">}{</a><a id="8741" href="/CallByName/#8741" class="Bound">γ</a><a id="8742" class="Symbol">}</a> <a id="8744" class="Symbol">{</a><a id="8745" class="Argument">σ</a> <a id="8747" class="Symbol">=</a> <a id="8749" href="/CallByName/#8749" class="Bound">σ</a><a id="8750" class="Symbol">}</a> <a id="8752" class="Symbol">{</a><a id="8753" href="/CallByName/#8753" class="Bound">L</a> <a id="8755" href="/Untyped/#4298" class="InductiveConstructor Operator">·</a> <a id="8757" href="/CallByName/#8757" class="Bound">M</a><a id="8758" class="Symbol">}</a> <a id="8760" class="Symbol">{</a><a id="8761" href="/CallByName/#8761" class="Bound">c</a><a id="8762" class="Symbol">}</a> <a id="8764" class="Symbol">(</a><a id="8765" href="/CallByName/#3337" class="InductiveConstructor">⇓-app</a> <a id="8771" class="Symbol">{</a><a id="8772" class="Argument">N</a> <a id="8774" class="Symbol">=</a> <a id="8776" href="/CallByName/#8776" class="Bound">N</a><a id="8777" class="Symbol">}</a> <a id="8779" href="/CallByName/#8779" class="Bound">L⇓ƛNδ</a> <a id="8785" href="/CallByName/#8785" class="Bound">N⇓c</a><a id="8788" class="Symbol">)</a> <a id="8790" href="/CallByName/#8790" class="Bound">γ≈ₑσ</a>
    <a id="8799" class="Keyword">with</a> <a id="8804" href="/CallByName/#8188" class="Function">⇓→—↠×𝔹</a><a id="8810" class="Symbol">{</a><a id="8811" class="Argument">σ</a> <a id="8813" class="Symbol">=</a> <a id="8815" href="/CallByName/#8749" class="Bound">σ</a><a id="8816" class="Symbol">}</a> <a id="8818" href="/CallByName/#8779" class="Bound">L⇓ƛNδ</a> <a id="8824" href="/CallByName/#8790" class="Bound">γ≈ₑσ</a>
<a id="8829" class="Symbol">...</a> <a id="8833" class="Symbol">|</a> <a id="8835" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8837" class="Symbol">_</a> <a id="8839" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8841" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8843" href="/CallByName/#8843" class="Bound">σL—↠ƛτN</a> <a id="8851" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8853" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8855" href="/CallByName/#8855" class="Bound">τ</a> <a id="8857" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8859" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8861" href="/CallByName/#8861" class="Bound">δ≈ₑτ</a> <a id="8866" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8868" href="/CallByName/#8868" class="Bound">≡ƛτN</a> <a id="8873" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8875" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8877" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8879" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="8881" class="Keyword">rewrite</a> <a id="8889" href="/CallByName/#8868" class="Bound">≡ƛτN</a>
    <a id="8898" class="Keyword">with</a> <a id="8903" href="/CallByName/#8188" class="Function">⇓→—↠×𝔹</a> <a id="8910" class="Symbol">{</a><a id="8911" class="Argument">σ</a> <a id="8913" class="Symbol">=</a> <a id="8915" href="/CallByName/#6773" class="Function">ext-subst</a> <a id="8925" href="/CallByName/#8855" class="Bound">τ</a> <a id="8927" class="Symbol">(</a><a id="8928" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="8930" class="Bound">σ</a> <a id="8932" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="8934" class="Bound">M</a><a id="8935" class="Symbol">)}</a> <a id="8938" class="Bound">N⇓c</a>
           <a id="8953" class="Symbol">(λ</a> <a id="8956" class="Symbol">{</a><a id="8957" href="/CallByName/#8957" class="Bound">x</a><a id="8958" class="Symbol">}</a> <a id="8960" class="Symbol">→</a> <a id="8962" href="/CallByName/#7150" class="Function">≈ₑ-ext</a><a id="8968" class="Symbol">{</a><a id="8969" class="Argument">σ</a> <a id="8971" class="Symbol">=</a> <a id="8973" href="/CallByName/#8855" class="Bound">τ</a><a id="8974" class="Symbol">}</a> <a id="8976" href="/CallByName/#8861" class="Bound">δ≈ₑτ</a> <a id="8981" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8983" class="Bound">σ</a> <a id="8985" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8987" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="8989" class="Bound">γ≈ₑσ</a> <a id="8994" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="8996" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="9001" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="9003" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="9005" class="Symbol">{</a><a id="9006" href="/CallByName/#8957" class="Bound">x</a><a id="9007" class="Symbol">})</a>
       <a id="9017" class="Symbol">|</a> <a id="9019" href="/LambdaReduction/#616" class="InductiveConstructor">β</a><a id="9020" class="Symbol">{</a><a id="9021" href="/Untyped/#3002" class="InductiveConstructor">∅</a><a id="9022" class="Symbol">}{</a><a id="9024" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="9026" href="/Untyped/#6623" class="Function">exts</a> <a id="9031" href="/CallByName/#8855" class="Bound">τ</a> <a id="9033" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="9035" class="Bound">N</a><a id="9036" class="Symbol">}{</a><a id="9038" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="9040" class="Bound">σ</a> <a id="9042" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="9044" class="Bound">M</a><a id="9045" class="Symbol">}</a>
<a id="9047" class="Symbol">...</a> <a id="9051" class="Symbol">|</a> <a id="9053" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="9055" href="/CallByName/#9055" class="Bound">N&#39;</a> <a id="9058" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="9060" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="9062" href="/CallByName/#9062" class="Bound">—↠N&#39;</a> <a id="9067" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="9069" href="/CallByName/#9069" class="Bound">c≈N&#39;</a> <a id="9074" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="9076" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="9078" class="Symbol">|</a> <a id="9080" href="/CallByName/#9080" class="Bound">ƛτN·σM—→</a>
    <a id="9093" class="Keyword">rewrite</a> <a id="9101" href="/Substitution/#23724" class="Function">sub-sub</a><a id="9108" class="Symbol">{</a><a id="9109" class="Argument">M</a> <a id="9111" class="Symbol">=</a> <a id="9113" class="Bound">N</a><a id="9114" class="Symbol">}{</a><a id="9116" class="Argument">σ₁</a> <a id="9119" class="Symbol">=</a> <a id="9121" href="/Untyped/#6623" class="Function">exts</a> <a id="9126" class="Bound">τ</a><a id="9127" class="Symbol">}{</a><a id="9129" class="Argument">σ₂</a> <a id="9132" class="Symbol">=</a> <a id="9134" href="/Untyped/#7359" class="Function">subst-zero</a> <a id="9145" class="Symbol">(</a><a id="9146" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="9148" class="Bound">σ</a> <a id="9150" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="9152" class="Bound">M</a><a id="9153" class="Symbol">)}</a> <a id="9156" class="Symbol">=</a>
    <a id="9162" class="Keyword">let</a> <a id="9166" href="/CallByName/#9166" class="Bound">rs</a> <a id="9169" class="Symbol">=</a> <a id="9171" class="Symbol">(</a><a id="9172" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="9174" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="9176" href="/Untyped/#6623" class="Function">exts</a> <a id="9181" class="Bound">τ</a> <a id="9183" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="9185" class="Bound">N</a><a id="9186" class="Symbol">)</a> <a id="9188" href="/Untyped/#4298" class="InductiveConstructor Operator">·</a> <a id="9190" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="9192" class="Bound">σ</a> <a id="9194" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="9196" class="Bound">M</a> <a id="9198" href="/LambdaReduction/#1001" class="InductiveConstructor Operator">—→⟨</a> <a id="9202" href="/CallByName/#9080" class="Bound">ƛτN·σM—→</a> <a id="9211" href="/LambdaReduction/#1001" class="InductiveConstructor Operator">⟩</a> <a id="9213" href="/CallByName/#9062" class="Bound">—↠N&#39;</a> <a id="9218" class="Keyword">in</a>
    <a id="9225" class="Keyword">let</a> <a id="9229" href="/CallByName/#9229" class="Bound">g</a> <a id="9231" class="Symbol">=</a> <a id="9233" href="/LambdaReduction/#1210" class="Function">—↠-trans</a> <a id="9242" class="Symbol">(</a><a id="9243" href="/LambdaReduction/#1923" class="Function">appL-cong</a> <a id="9253" class="Bound">σL—↠ƛτN</a><a id="9260" class="Symbol">)</a> <a id="9262" href="/CallByName/#9166" class="Bound">rs</a> <a id="9265" class="Keyword">in</a>
    <a id="9272" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="9274" href="/CallByName/#9055" class="Bound">N&#39;</a> <a id="9277" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="9279" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="9281" href="/CallByName/#9229" class="Bound">g</a> <a id="9283" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="9285" href="/CallByName/#9069" class="Bound">c≈N&#39;</a> <a id="9290" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="9292" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>

<p>The proof is by induction on <code class="highlighter-rouge">γ ⊢ M ⇓ c</code>. We have three cases
to consider.</p>

<ul>
  <li>
    <p>Case <code class="highlighter-rouge">⇓-var</code>.
So we have <code class="highlighter-rouge">γ x ≡ clos L δ</code> and <code class="highlighter-rouge">δ ⊢ L ⇓ c</code>.
We need to show that <code class="highlighter-rouge">⟪ σ ⟫ x —↠ N</code> and <code class="highlighter-rouge">c ≈ N</code> for some <code class="highlighter-rouge">N</code>.
The premise <code class="highlighter-rouge">γ ≈ₑ σ</code> tells us that <code class="highlighter-rouge">γ x ≈ σ x</code>, so <code class="highlighter-rouge">clos L δ ≈ σ x</code>.
By the definition of <code class="highlighter-rouge">≈</code>, there exists a <code class="highlighter-rouge">τ</code> such that
<code class="highlighter-rouge">δ ≈ₑ τ</code> and <code class="highlighter-rouge">σ x ≡ ⟪ τ ⟫ L </code>.
Using <code class="highlighter-rouge">δ ⊢ L ⇓ c</code> and <code class="highlighter-rouge">δ ≈ₑ τ</code>, 
the induction hypothesis gives us
<code class="highlighter-rouge">⟪ τ ⟫ L —↠ N</code> and <code class="highlighter-rouge">c ≈ N</code> for some <code class="highlighter-rouge">N</code>.
So we have shown that <code class="highlighter-rouge">⟪ σ ⟫ x —↠ N</code> and <code class="highlighter-rouge">c ≈ N</code> for some <code class="highlighter-rouge">N</code>.</p>
  </li>
  <li>
    <p>Case <code class="highlighter-rouge">⇓-lam</code>.
We immediately have <code class="highlighter-rouge">⟪ σ ⟫ (ƛ N) —↠ ⟪ σ ⟫ (ƛ N)</code>
and <code class="highlighter-rouge">clos (⟪ σ ⟫ (ƛ N)) γ ≈ ⟪ σ ⟫ (ƛ N)</code>.</p>
  </li>
  <li>
    <p>Case <code class="highlighter-rouge">⇓-app</code>.
Using <code class="highlighter-rouge">γ ⊢ L ⇓ clos N δ</code> and <code class="highlighter-rouge">γ ≈ₑ σ</code>, 
the induction hypothesis gives us</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ⟪ σ ⟫ L —↠ ƛ ⟪ exts τ ⟫ N                                           (1)
</code></pre></div>    </div>

    <p>and <code class="highlighter-rouge">δ ≈ₑ τ</code> for some <code class="highlighter-rouge">τ</code>.
From <code class="highlighter-rouge">γ≈ₑσ</code> we have <code class="highlighter-rouge">clos M γ ≈ ⟪ σ ⟫ M</code>.
Then with <code class="highlighter-rouge">(δ ,' clos M γ) ⊢ N ⇓ c</code>,
the induction hypothesis gives us <code class="highlighter-rouge">c ≈ N'</code> and</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ⟪ exts τ ⨟ subst-zero (⟪ σ ⟫ M) ⟫ N —↠ N'                           (2)
</code></pre></div>    </div>

    <p>Meanwhile, by <code class="highlighter-rouge">β</code>, we have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ ⟪ exts τ ⟫ N) · ⟪ σ ⟫ M —→ ⟪ subst-zero (⟪ σ ⟫ M) ⟫ (⟪ exts τ ⟫ N)
</code></pre></div>    </div>

    <p>which is the same as the following, by <code class="highlighter-rouge">sub-sub</code>.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ ⟪ exts τ ⟫ N) · ⟪ σ ⟫ M —→ ⟪ exts τ ⨟ subst-zero (⟪ σ ⟫ M) ⟫  N  (3)
</code></pre></div>    </div>

    <p>Using (3) and (2) we have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ ⟪ exts τ ⟫ N) · ⟪ σ ⟫ M —↠ N'                                    (4)
</code></pre></div>    </div>

    <p>From (1) we have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ⟪ σ ⟫ L · ⟪ σ ⟫ M —↠ (ƛ ⟪ exts τ ⟫ N) · ⟪ σ ⟫ M
</code></pre></div>    </div>

    <p>which we combine with (4) to conclude that</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ⟪ σ ⟫ L · ⟪ σ ⟫ M —↠ N'
</code></pre></div>    </div>
  </li>
</ul>

<p>With the main lemma complete, we establish the forward direction
of the equivalence between the big-step semantics and beta reduction.</p>

<pre class="Agda"><a id="cbn→reduce"></a><a id="11052" href="/CallByName/#11052" class="Function">cbn→reduce</a> <a id="11063" class="Symbol">:</a>  <a id="11066" class="Symbol">∀{</a><a id="11068" href="/CallByName/#11068" class="Bound">M</a> <a id="11070" class="Symbol">:</a> <a id="11072" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="11074" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="11076" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="11077" class="Symbol">}{</a><a id="11079" href="/CallByName/#11079" class="Bound">Δ</a><a id="11080" class="Symbol">}{</a><a id="11082" href="/CallByName/#11082" class="Bound">δ</a> <a id="11084" class="Symbol">:</a> <a id="11086" href="/CallByName/#2422" class="Function">ClosEnv</a> <a id="11094" href="/CallByName/#11079" class="Bound">Δ</a><a id="11095" class="Symbol">}{</a><a id="11097" href="/CallByName/#11097" class="Bound">N′</a> <a id="11100" class="Symbol">:</a> <a id="11102" href="/CallByName/#11079" class="Bound">Δ</a> <a id="11104" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="11106" href="/Untyped/#2694" class="InductiveConstructor">★</a> <a id="11108" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="11110" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="11111" class="Symbol">}</a>
     <a id="11118" class="Symbol">→</a> <a id="11120" href="/CallByName/#2651" class="Function">∅&#39;</a> <a id="11123" href="/CallByName/#3038" class="Datatype Operator">⊢</a> <a id="11125" href="/CallByName/#11068" class="Bound">M</a> <a id="11127" href="/CallByName/#3038" class="Datatype Operator">⇓</a> <a id="11129" href="/CallByName/#2471" class="InductiveConstructor">clos</a> <a id="11134" class="Symbol">(</a><a id="11135" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="11137" href="/CallByName/#11097" class="Bound">N′</a><a id="11139" class="Symbol">)</a> <a id="11141" href="/CallByName/#11082" class="Bound">δ</a>
       <a id="11150" class="Comment">-----------------------------</a>
     <a id="11185" class="Symbol">→</a> <a id="11187" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">Σ[</a> <a id="11190" href="/CallByName/#11190" class="Bound">N</a> <a id="11192" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">∈</a> <a id="11194" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="11196" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="11198" href="/Untyped/#2694" class="InductiveConstructor">★</a> <a id="11200" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="11202" href="/Untyped/#2694" class="InductiveConstructor">★</a> <a id="11204" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#764" class="Function">]</a> <a id="11206" class="Symbol">(</a><a id="11207" href="/CallByName/#11068" class="Bound">M</a> <a id="11209" href="/LambdaReduction/#894" class="Datatype Operator">—↠</a> <a id="11212" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="11214" href="/CallByName/#11190" class="Bound">N</a><a id="11215" class="Symbol">)</a>
<a id="11217" href="/CallByName/#11052" class="Function">cbn→reduce</a> <a id="11228" class="Symbol">{</a><a id="11229" href="/CallByName/#11229" class="Bound">M</a><a id="11230" class="Symbol">}{</a><a id="11232" href="/CallByName/#11232" class="Bound">Δ</a><a id="11233" class="Symbol">}{</a><a id="11235" href="/CallByName/#11235" class="Bound">δ</a><a id="11236" class="Symbol">}{</a><a id="11238" href="/CallByName/#11238" class="Bound">N′</a><a id="11240" class="Symbol">}</a> <a id="11242" href="/CallByName/#11242" class="Bound">M⇓c</a>
    <a id="11250" class="Keyword">with</a> <a id="11255" href="/CallByName/#8188" class="Function">⇓→—↠×𝔹</a><a id="11261" class="Symbol">{</a><a id="11262" class="Argument">σ</a> <a id="11264" class="Symbol">=</a> <a id="11266" href="/Substitution/#3179" class="Function">ids</a><a id="11269" class="Symbol">}</a> <a id="11271" href="/CallByName/#11242" class="Bound">M⇓c</a> <a id="11275" href="/CallByName/#6655" class="Function">≈ₑ-id</a>
<a id="11281" class="Symbol">...</a> <a id="11285" class="Symbol">|</a> <a id="11287" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="11289" href="/CallByName/#11289" class="Bound">N</a> <a id="11291" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="11293" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="11295" href="/CallByName/#11295" class="Bound">rs</a> <a id="11298" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="11300" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="11302" href="/CallByName/#11302" class="Bound">σ</a> <a id="11304" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="11306" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="11308" href="/CallByName/#11308" class="Bound">h</a> <a id="11310" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="11312" href="/CallByName/#11312" class="Bound">eq2</a> <a id="11316" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="11318" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="11320" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="11322" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
    <a id="11328" class="Keyword">rewrite</a> <a id="11336" href="/Substitution/#17610" class="Function">sub-id</a><a id="11342" class="Symbol">{</a><a id="11343" class="Argument">M</a> <a id="11345" class="Symbol">=</a> <a id="11347" class="Bound">M</a><a id="11348" class="Symbol">}</a> <a id="11350" class="Symbol">|</a> <a id="11352" href="/CallByName/#11312" class="Bound">eq2</a> <a id="11356" class="Symbol">=</a>
    <a id="11362" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="11364" href="/Substitution/#2663" class="Function Operator">⟪</a> <a id="11366" href="/Untyped/#6623" class="Function">exts</a> <a id="11371" href="/CallByName/#11302" class="Bound">σ</a> <a id="11373" href="/Substitution/#2663" class="Function Operator">⟫</a> <a id="11375" class="Bound">N′</a> <a id="11378" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="11380" href="/CallByName/#11295" class="Bound">rs</a> <a id="11383" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>

<p>The proof of the backward direction, that beta reduction to a lambda
implies that the big-step semantics produces a result, will leverage the
denotational semantics defined in the next chapter, and appears in the
chapter on Adequacy.</p>

<h2 id="notes">Notes</h2>

<p>In the seminal article <em>Call-by-name, call-by-value, and the
λ-calculus</em>, Plotkin defined a call-by-name partial function similar
to the big-step semantics in this chapter, except that it used
substitution instead of environments. Corollary 2 (page 146) of his
article states that a term <code class="highlighter-rouge">M</code> beta reduces to a lambda abstraction if
and only if call-by-name produces a value. His proof is quite
different from ours in that it relies on two auxilliary reduction
relations called <em>left reduction</em> and <em>standard reduction</em>. Theorem 1
(Standardisation) states that <code class="highlighter-rouge">M —↠ L</code> if and only if <code class="highlighter-rouge">M</code> goes to <code class="highlighter-rouge">L</code>
via standard reductions.  Corollary 1 then establishes that <code class="highlighter-rouge">M —↠ ƛ N</code>
if and only if <code class="highlighter-rouge">M</code> goes to <code class="highlighter-rouge">ƛ N′</code>, for some <code class="highlighter-rouge">N′</code>, by left
reduction. Theorem 2 then connects call-by-name evaluation to left
reduction.  Finally, Corollary 2 combines these results to show that
<code class="highlighter-rouge">M —↠ ƛ N</code> if and only if call-by-name produces a value.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>≈  U+2248  ALMOST EQUAL TO (\~~ or \approx)
ₑ  U+2091  LATIN SUBSCRIPT SMALL LETTER E (\_e)
⊢  U+22A2  RIGHT TACK (\|- or \vdash)
⇓  U+21DB  DOWNWARDS DOUBLE ARROW (\d= or \Downarrow)
</code></pre></div></div>


  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/Confluence/">Prev</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/CallByName.lagda">Source</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/Denotational/">Next</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programming Language Foundations in Agda
</h2><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/assets/jquery.js"></script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
